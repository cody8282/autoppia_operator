[
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "urllib.error",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.error",
        "description": "urllib.error",
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "HTMLParser",
        "importPath": "html.parser",
        "description": "html.parser",
        "isExtraImport": true,
        "detail": "html.parser",
        "documentation": {}
    },
    {
        "label": "Body",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "Task",
        "importPath": "autoppia_iwa.src.data_generation.tasks.classes",
        "description": "autoppia_iwa.src.data_generation.tasks.classes",
        "isExtraImport": true,
        "detail": "autoppia_iwa.src.data_generation.tasks.classes",
        "documentation": {}
    },
    {
        "label": "AsyncStatefulEvaluator",
        "importPath": "autoppia_iwa.src.evaluation.stateful_evaluator",
        "description": "autoppia_iwa.src.evaluation.stateful_evaluator",
        "isExtraImport": true,
        "detail": "autoppia_iwa.src.evaluation.stateful_evaluator",
        "documentation": {}
    },
    {
        "label": "BaseAction",
        "importPath": "autoppia_iwa.src.execution.actions.base",
        "description": "autoppia_iwa.src.execution.actions.base",
        "isExtraImport": true,
        "detail": "autoppia_iwa.src.execution.actions.base",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "api",
        "description": "api",
        "isExtraImport": true,
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "_Candidate",
        "kind": 6,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "class _Candidate:\n    def __init__(self, selector: str, text: str, tag: str, attrs: Dict[str, str]):\n        self.selector = selector\n        self.text = text\n        self.tag = tag\n        self.attrs = attrs\nclass _CandidateExtractor(HTMLParser):\n    def __init__(self) -> None:\n        super().__init__()\n        self._stack: List[str] = []",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "_CandidateExtractor",
        "kind": 6,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "class _CandidateExtractor(HTMLParser):\n    def __init__(self) -> None:\n        super().__init__()\n        self._stack: List[str] = []\n        self._current_text: List[str] = []\n        self._last_tag: Optional[str] = None\n        self._last_attrs: Dict[str, str] = {}\n        self.candidates: List[_Candidate] = []\n    def handle_starttag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]) -> None:\n        attr_map = {k: (v or \"\") for k, v in attrs}",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "LLMGateway",
        "kind": 6,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "class LLMGateway:\n    \"\"\"Minimal gateway-style client that adds IWA-Task-Id for subnet tracking.\"\"\"\n    def __init__(self) -> None:\n        self.base_url = os.getenv(\"OPENAI_BASE_URL\", \"https://api.openai.com/v1\").rstrip(\"/\")\n        self.api_key = os.getenv(\"OPENAI_API_KEY\", \"\")\n    def predict(self, *, task_id: str, messages: List[Dict[str, Any]], model: str) -> Dict[str, Any]:\n        if not self.api_key:\n            raise RuntimeError(\"OPENAI_API_KEY not set\")\n        body = {\n            \"model\": model,",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "FIXED_AUTBOOKS_URL",
        "kind": 5,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "FIXED_AUTBOOKS_URL = os.getenv(\n    \"FIXED_AUTBOOKS_URL\",\n    \"http://84.247.180.192:8001/books/book-original-002?seed=36\",\n)\napp = FastAPI(title=\"Autoppia Web Agent API\")\n@app.get(\"/health\", summary=\"Health check\")\nasync def health() -> Dict[str, str]:\n    return {\"status\": \"healthy\"}\nclass _Candidate:\n    def __init__(self, selector: str, text: str, tag: str, attrs: Dict[str, str]):",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "app = FastAPI(title=\"Autoppia Web Agent API\")\n@app.get(\"/health\", summary=\"Health check\")\nasync def health() -> Dict[str, str]:\n    return {\"status\": \"healthy\"}\nclass _Candidate:\n    def __init__(self, selector: str, text: str, tag: str, attrs: Dict[str, str]):\n        self.selector = selector\n        self.text = text\n        self.tag = tag\n        self.attrs = attrs",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "_llm_gateway",
        "kind": 5,
        "importPath": "api",
        "description": "api",
        "peekOfCode": "_llm_gateway = LLMGateway()\ndef _call_openai(task_id: str, messages: List[Dict[str, Any]], model: str) -> Dict[str, Any]:\n    api_key = os.getenv(\"OPENAI_API_KEY\")\n    if not api_key:\n        raise RuntimeError(\"OPENAI_API_KEY not set\")\n    return _llm_gateway.predict(task_id=task_id, messages=messages, model=model)\ndef _llm_decide(\n    task_id: str,\n    task: str,\n    url: str,",
        "detail": "api",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "check",
        "description": "check",
        "peekOfCode": "def main() -> None:\n    main_py = REPO_ROOT / \"main.py\"\n    api_py = REPO_ROOT / \"api.py\"\n    _ok(f\"Found {api_py.name}\")\n    main_mod = _load_module(main_py, \"main\")\n    app = getattr(main_mod, \"app\", None)\n    if app is None:\n        _fail(\"main.py does not expose `app`\")\n    _ok(\"main.py exposes `app`\")\n    if not _find_route(app, \"/health\", \"GET\"):",
        "detail": "check",
        "documentation": {}
    },
    {
        "label": "REPO_ROOT",
        "kind": 5,
        "importPath": "check",
        "description": "check",
        "peekOfCode": "REPO_ROOT = Path(__file__).resolve().parent\ndef _fail(msg: str) -> None:\n    print(f\"[FAIL] {msg}\")\n    sys.exit(1)\ndef _ok(msg: str) -> None:\n    print(f\"[OK] {msg}\")\ndef _load_module(path: Path, name: str):\n    if not path.exists():\n        _fail(f\"Missing {path.name}\")\n    spec = importlib.util.spec_from_file_location(name, path)",
        "detail": "check",
        "documentation": {}
    },
    {
        "label": "load_tasks",
        "kind": 2,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "def load_tasks(\n    cache_path: Path = TASK_CACHE,\n    use_case: str | None = None,\n    limit: int = 20,\n) -> list[Task]:\n    \"\"\"Load tasks from the JSON cache, optionally filtered by use case.\"\"\"\n    with open(cache_path) as f:\n        data = json.load(f)\n    raw_tasks = data[\"tasks\"] if isinstance(data, dict) and \"tasks\" in data else data\n    tasks: list[Task] = []",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "inject_seed",
        "kind": 2,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "def inject_seed(task: Task) -> tuple[Task, int]:\n    \"\"\"Inject a random seed into the task URL for variation.\"\"\"\n    t = deepcopy(task)\n    seed = random.randint(1, 100_000)\n    base_url = t.url.split(\"?\")[0] if \"?\" in t.url else t.url\n    t.url = f\"{base_url}?seed={seed}\"\n    return t, seed\n# ── Main evaluation loop ────────────────────────────────────────\nasync def run_evaluation(\n    model: str = \"gpt-4o-mini\",",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "def main():\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Autoppia Operator - LLM Agent Evaluation\")\n    parser.add_argument(\"--model\", default=\"gpt-4o-mini\", help=\"OpenAI model name\")\n    parser.add_argument(\"--num-tasks\", type=int, default=20, help=\"Number of tasks to evaluate\")\n    parser.add_argument(\"--max-steps\", type=int, default=15, help=\"Max steps per episode\")\n    parser.add_argument(\"--use-case\", default=None, help=\"Filter by use case (e.g. SEARCH_FILM)\")\n    parser.add_argument(\"--temperature\", type=float, default=0.2, help=\"LLM temperature\")\n    args = parser.parse_args()\n    asyncio.run(",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "SCRIPT_DIR",
        "kind": 5,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "SCRIPT_DIR = Path(__file__).resolve().parent\nOPERATOR_ROOT = SCRIPT_DIR.parent\nsys.path.insert(0, str(OPERATOR_ROOT))\nsys.path.insert(0, str(SCRIPT_DIR))\n# ── Load .env from autoppia_operator ────────────────────────────\nfrom dotenv import load_dotenv\noperator_env = SCRIPT_DIR / \".env\"\nif operator_env.exists():\n    load_dotenv(operator_env, override=True)\n# ── Imports ──────────────────────────────────────────────────────",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "OPERATOR_ROOT",
        "kind": 5,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "OPERATOR_ROOT = SCRIPT_DIR.parent\nsys.path.insert(0, str(OPERATOR_ROOT))\nsys.path.insert(0, str(SCRIPT_DIR))\n# ── Load .env from autoppia_operator ────────────────────────────\nfrom dotenv import load_dotenv\noperator_env = SCRIPT_DIR / \".env\"\nif operator_env.exists():\n    load_dotenv(operator_env, override=True)\n# ── Imports ──────────────────────────────────────────────────────\nfrom loguru import logger",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "operator_env",
        "kind": 5,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "operator_env = SCRIPT_DIR / \".env\"\nif operator_env.exists():\n    load_dotenv(operator_env, override=True)\n# ── Imports ──────────────────────────────────────────────────────\nfrom loguru import logger\nfrom autoppia_iwa.src.data_generation.tasks.classes import Task\nfrom autoppia_iwa.src.evaluation.stateful_evaluator import AsyncStatefulEvaluator\nfrom autoppia_iwa.src.execution.actions.base import BaseAction\n# Default task cache path\nTASK_CACHE = OPERATOR_ROOT / \"autoppia_rl\" / \"data\" / \"task_cache\" / \"autoppia_cinema_tasks.json\"",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "TASK_CACHE",
        "kind": 5,
        "importPath": "eval",
        "description": "eval",
        "peekOfCode": "TASK_CACHE = OPERATOR_ROOT / \"autoppia_rl\" / \"data\" / \"task_cache\" / \"autoppia_cinema_tasks.json\"\nrandom.seed(time.time())\n# ── Task loading ─────────────────────────────────────────────────\ndef load_tasks(\n    cache_path: Path = TASK_CACHE,\n    use_case: str | None = None,\n    limit: int = 20,\n) -> list[Task]:\n    \"\"\"Load tasks from the JSON cache, optionally filtered by use case.\"\"\"\n    with open(cache_path) as f:",
        "detail": "eval",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "__all__ = [\"app\"]",
        "detail": "main",
        "documentation": {}
    }
]